import pandas as pd
import numpy as np
from datetime import datetime

# Assuming you already have data loaded into DataFrames (t1, t2, t3, t4) 
# which are the equivalent of your SAS tables (SF_FNRPT.f_FINANCE_SUMMARY, REF.MR_LOB_REF)
# You'll need to load your data into pandas DataFrames (e.g., using pd.read_csv, pd.read_sql, etc.)

# Example mock DataFrames (replace with actual data loading logic)
# t1 = pd.read_sql("SELECT * FROM SF_FNRPT.f_FINANCE_SUMMARY", conn)
# t2 = pd.read_sql("SELECT * FROM REF.MR_LOB_REF", conn)

# Define the variables (bookClose, currentYear, priorYear, currentMonth, priorMonth)
bookClose = datetime.strptime('01Nov2024', '%d%b%Y')
currentYear = bookClose.year
currentMonth = bookClose.month
priorMonth = (bookClose.replace(day=1) - pd.DateOffset(months=1)).month
priorYear = (bookClose.replace(day=1) - pd.DateOffset(months=1)).year

# Step 1: MR_temp table (creating the temporary table using SQL-style aggregation)

# Create t1 (and t2) DataFrames, join them, apply case conditions
# In pandas, we can use the `np.where` or `apply` function to handle conditions
t1['State'] = t1['CVRG_ST_ABBR_CD'].apply(lambda x: 'State NA' if x in [' ', '', 'XX'] else x)
t1['Distribution'] = t1['DSTBTN_CD'].apply(lambda x: 'D0000' if x == '~' else x)
t1['Vol_Invol'] = t1['VOLNTRY_INVOL_CD'].apply(lambda x: 'Voluntary' if x in [' ', '', '~'] else x)

# Group by the relevant columns and aggregate the sums
MR_temp = t1.groupby(['BUS_TYPE', 'CVRG_ST_ABBR_CD', 'DSTBTN_CD', 'LOB', 'GL_LOB', 'CVRG_TYP', 'POLICY_TERM_CD', 'VOLNTRY_INVOL_CD']).agg(
    Written_Premium_NB=('WRIT_PREM_AMT', lambda x: x[t1['NEW_RNWL_DESC'] == 'NEW'].sum()),
    Written_Premium_RB=('WRIT_PREM_AMT', lambda x: x[t1['NEW_RNWL_DESC'] == 'RENEWAL'].sum()),
    Earned_Premium=('ERND_PREM_AMT', 'sum'),
    CY_CAT_Loss_Paid=('NET_LOSS_PAID_AMT', lambda x: x[(t1['PY_CY_IND'] == 'CY') & (t1['CAT_IND'] == 'Y')].sum()),
    CY_Non_CAT_Loss_Paid=('NET_LOSS_PAID_AMT', lambda x: x[(t1['PY_CY_IND'] == 'CY') & (t1['CAT_IND'] == 'N')].sum()),
    PY_CAT_Loss_Paid=('NET_LOSS_PAID_AMT', lambda x: x[(t1['PY_CY_IND'] == 'PY') & (t1['CAT_IND'] == 'Y')].sum()),
    PY_Non_CAT_Loss_Paid=('NET_LOSS_PAID_AMT', lambda x: x[(t1['PY_CY_IND'] == 'PY') & (t1['CAT_IND'] == 'N')].sum())
).reset_index()

# Apply other aggregations for ALAE and reserves (CY and PY) similarly

# Step 2: MR_agg table (grouping and summing values)
MR_agg = MR_temp.groupby(['BookDate', 'Reinsurance', 'State', 'Distribution', 'Line', 'GL_LOB', 'Coverage', 'Term', 'Vol_Invol']).agg(
    Written_Premium_NB=('Written_Premium_NB', 'sum'),
    Written_Premium_RB=('Written_Premium_RB', 'sum'),
    Earned_Premium=('Earned_Premium', 'sum'),
    CY_CAT_Loss_Paid=('CY_CAT_Loss_Paid', 'sum'),
    CY_Non_CAT_Loss_Paid=('CY_Non_CAT_Loss_Paid', 'sum'),
    PY_CAT_Loss_Paid=('PY_CAT_Loss_Paid', 'sum'),
    PY_Non_CAT_Loss_Paid=('PY_Non_CAT_Loss_Paid', 'sum')
).reset_index()

# Step 3: Transpose the data (equivalent of PROC TRANSPOSE in SAS)
MR_Final = pd.melt(MR_agg, id_vars=['BookDate', 'Reinsurance', 'State', 'Distribution', 'Line', 'GL_LOB', 'Coverage', 'Term', 'Vol_Invol'], 
                   value_vars=['Written_Premium_NB', 'Written_Premium_RB', 'Earned_Premium', 'CY_CAT_Loss_Paid', 
                               'CY_Non_CAT_Loss_Paid', 'PY_CAT_Loss_Paid', 'PY_Non_CAT_Loss_Paid'], 
                   var_name='Account', value_name='Amount')

# Step 4: Export the final DataFrame to a CSV or database
MR_Final.to_csv('MR_Final.csv', index=False)

# For SQLite or SQLAlchemy
# MR_Final.to_sql('MR_Final', conn, if_exists='replace', index=False)

print("Process completed.")
